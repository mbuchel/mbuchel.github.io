<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Knowledges on Michael Buchel</title><link>https://mbuchel.github.io/knowledge/</link><description>Recent content in Knowledges on Michael Buchel</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 10 Aug 2019 20:58:25 -0400</lastBuildDate><atom:link href="https://mbuchel.github.io/knowledge/index.xml" rel="self" type="application/rss+xml"/><item><title>Jetson</title><link>https://mbuchel.github.io/knowledge/jetson/</link><pubDate>Sat, 10 Aug 2019 20:58:25 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/jetson/</guid><description>Background Knowledge: The Jetson TX2 is a Nvidia embedded computer, which is an arm cortex CPU and a nvidia graphics card. This is the 3rd of the Jetson family with the newest addition being the Jetson Xavier. I had experience working with all previous Jetsons as well, and as with all things Nvidia + linux the task was not easy.
Quick Run: The main issue I had was the outdated OpenCV for Tegra, several computer vision techniques have been added in later OpenCV versions which just cannot show up in the OpenCV for Tegra.</description></item><item><title>Superquadratics</title><link>https://mbuchel.github.io/knowledge/superquadratics/</link><pubDate>Sat, 10 Aug 2019 20:58:20 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/superquadratics/</guid><description>Background Knowledge: Bounding objects are now quite a common technique for object identification. Unfortunately objects are quite complex, to combat this a particular class of geometric shapes have been developed. This class is superquadratics, and they are defined by functions which resemble those of ellipsoids and other quadrics, however the square is replaced by arbitrary powers.
Quick Run: A superquadratic function is defined as follows:
$$|x|^r + |y|^s + |z|^t = 1$$</description></item><item><title>Model Fitting</title><link>https://mbuchel.github.io/knowledge/model-fitting/</link><pubDate>Sat, 10 Aug 2019 20:58:12 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/model-fitting/</guid><description>Background Knowledge: Model fitting is a problem that has been around as long as physics. The main purpose of physics is to reliably predict the changes in the world around us. Unfortunately while research has been done in this field, it is quite limited and we can only fit models to specific datasets. While this is the case, we have simpler methods for the time being, such as neural networks.</description></item><item><title>Real Time</title><link>https://mbuchel.github.io/knowledge/real-time/</link><pubDate>Sat, 10 Aug 2019 20:58:01 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/real-time/</guid><description>Background Knowledge: Human computer interfaces are growing more prominent as we enter a more digitalized society. Robotics must react to split second decisions, in a quick and timely manner. In the case of self driving cars it is even more important as we see now, that effects must be instantaneous. Most robotics systems today unfortunately do not use RTOS systems, but rather use ROS. Which has quite a large delay in processing information.</description></item><item><title>HMM vs CNN vs RNN</title><link>https://mbuchel.github.io/knowledge/hmm-vs-cnn-vs-rnn/</link><pubDate>Sat, 10 Aug 2019 20:57:47 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/hmm-vs-cnn-vs-rnn/</guid><description>Background Knowledge: Machine learning is another field which takes a larger portion of our lives. Unfortunately when talking with most individuals their knowledge of machine learning can be summed up quite quickly under the umbrella term neural network. They know nothing about different neural network topologies, and much less about concepts like Boosting which helps you train neural networks. They mostly worked with one or two frameworks such as tensorflow or caffe, and fewer still know about model fitting or superquadratics which work on identifying quite a lot of models.</description></item><item><title>Server API Design</title><link>https://mbuchel.github.io/knowledge/server-api-design/</link><pubDate>Sat, 10 Aug 2019 20:57:27 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/server-api-design/</guid><description>Background Knowledge: Servers are the backbone of all our smart electronics now, they act as the brains behind our connected devices. As such, server design is an ever increasing field of coding. Unfortunately, we have some poorly designed servers, and there is no standardized rules for server design. From my experience coding servers, I have learned some of the standards in a few companies. Which I took from this what works and what does not, and implemented this as the standards for server programming at MIM.</description></item><item><title>Android Programming</title><link>https://mbuchel.github.io/knowledge/android-programming/</link><pubDate>Sat, 10 Aug 2019 20:57:08 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/android-programming/</guid><description>Background Knowledge: As smart phones become a more permanent part of our lives, we must grow to accept and work with them. Android programming is a HUGE field and the Android team has done a very good job with their documentation. So this will focus on the less known areas of Android programming.
Quick Run: The nicest area of android programming has been a change from Java into Kotlin. This has allowed for more complex software designs, as well as a movement away from object oriented programming into more procedural paradigms.</description></item><item><title>Camera Calibration</title><link>https://mbuchel.github.io/knowledge/camera-calibration/</link><pubDate>Sat, 10 Aug 2019 20:56:48 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/camera-calibration/</guid><description>Background Knowledge: Calibration for sensors is arguably the most important step you can take for making sense of data. This was without a doubt the hardest task we had at Mycionics, due to the complexity involved in a proper camera calibration. There are multiple types of camera calibrations, depending on your particular application a different calibration should be used. I will only go over the ones offered by OpenCV libraries.</description></item><item><title>Build Systems</title><link>https://mbuchel.github.io/knowledge/build-systems/</link><pubDate>Sat, 10 Aug 2019 20:56:34 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/build-systems/</guid><description>Background Knowledge: Build systems are essential for a programmer to know, without it you will never be able to compile large scale programs. It is vital to know both the compiler you are using as well as the build system, as the program you make will be limited by both. Unfortunately there have not been many good tutorials on Makefiles, for that reason majority of this post will be on Makefiles.</description></item><item><title>Kicad</title><link>https://mbuchel.github.io/knowledge/kicad/</link><pubDate>Sat, 10 Aug 2019 20:56:15 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/kicad/</guid><description>Background Knowledge: Electronics engineers use computer assisted drawing tools in order to create PCBs. No longer must engineers draw circuit boards by hand and place them in acid to create the PCBs. As such we get a list of possible CADs for electronic engineers. Unfortunately this list is incredibly extensive, so I will limit my discussion to KiCad specifically.
Quick Run: Out of the 3 CADs (OrCad, Eagle, KiCad), KiCad was the one that offered the most extensibility, as well as being completely free.</description></item><item><title>STM</title><link>https://mbuchel.github.io/knowledge/stm/</link><pubDate>Sat, 10 Aug 2019 20:56:11 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/stm/</guid><description>Background Knowledge: The picture above is an STM32F429 dev board which has Doom working on it. The Doom port is Chocolate Doom, and I used it as an experience to figure out how to code for the STM32 this way. STM32 is a 32 bit ARM CPU specifically designed for embedded systems. I had to work with the STM32 for the MR-Clutch arm robot, where it was supposed to act as the controller for the arm, and the Jetson TX2 was the brain of the system.</description></item><item><title>QT vs GTK</title><link>https://mbuchel.github.io/knowledge/qt-vs-gtk/</link><pubDate>Sat, 10 Aug 2019 20:56:07 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/qt-vs-gtk/</guid><description>Background Knowledge: There are many frameworks and graphics toolkits for cross platform development. The main 2 that are used by linux users are GTK and QT. I personally prefer QT, however I will explain how to use GTK as well in this post. The fundamental difference between the 2 is that QT is it&amp;rsquo;s own framework, and has a specific build system for QT applications (a particular engineer I know also used that build system to program STM32 controllers).</description></item><item><title>Compression</title><link>https://mbuchel.github.io/knowledge/compression/</link><pubDate>Sat, 10 Aug 2019 20:55:45 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/compression/</guid><description>Background Knowledge: Compression is one of the key outcomes of information theory, which should be studied by every single engineer regardless the area of engineering they are in. Without compression we create systems which use unnecessary data.
Quick Run: Compression has many different subfields in it, I will only talk about a few that I have become aqquinted with.
Huffman Encoding: This is one of the simplest compression schemes. Unfortunately, this is poor for dynamically changing sources of information.</description></item><item><title>Sensors</title><link>https://mbuchel.github.io/knowledge/sensors/</link><pubDate>Sat, 10 Aug 2019 20:55:33 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/sensors/</guid><description>Background Knowledge: Most of my work in sensors, has been in designing biofeedback wearable devices, such as WearME Brace. While I also have experience in other sensor systems, such as cameras and hall effect sensors, this post will be a quick rundown of all the specifics needed in order to make a reliable sensor system.
Quick Run: The first thing to know for sensor design is: what are you trying to achieve?</description></item><item><title>Communications Protocols</title><link>https://mbuchel.github.io/knowledge/communications-protocols/</link><pubDate>Sat, 10 Aug 2019 20:55:27 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/communications-protocols/</guid><description>Background Knowledge: All connected devices require a communication protocol of one kind or another in order to inform the other device of what task it should perform next. Or as to the result of the task the device has performed. Now there are plenty of hardware based approaches I have worked on, and several more software based ones. Due to the vast magnitude I will just briefly touch upon some of them, feel free to contact me if you want a more indepth explanation of how the different protocols work.</description></item><item><title>Power Control</title><link>https://mbuchel.github.io/knowledge/power-control/</link><pubDate>Sat, 10 Aug 2019 20:40:09 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/power-control/</guid><description>Background Knowledge: All electrical systems require a proper power management system. My main experience with power management has been in the battery management field as well as wireless harvesting. However due to practicality issues involved with wireless harvesting the purpose of this post will be focused on battery power management, as well as power supply management.
Quick Run: There are plenty of circuits for controlling the charge a lithium ion battery gets.</description></item><item><title>Motor Control</title><link>https://mbuchel.github.io/knowledge/motor-control/</link><pubDate>Sat, 10 Aug 2019 19:16:38 -0400</pubDate><guid>https://mbuchel.github.io/knowledge/motor-control/</guid><description>Background Knowledge: The first half of the picture is called a 3 phase inverter circuit, while the second half is the actual motor. These type of setups are common in AC motor control, I will ignore DC control schemes for motors are they are for the most part straightforward and do not have different kinds of control schemes which is common in AC motor systems.
Quick Run: AC motors are playing a bigger role than ever in our ever increasingly automated world, due to the reduced cost and power consumption.</description></item></channel></rss>